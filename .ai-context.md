# AI Assistant Context for iRacing Safety Car Generator

Patterns, conventions, extension points, and gotchas. For module-level reference, see `.ai-modules.md`.

## Quick Reference

- **Language:** Python 3.13
- **Architecture:** Event-driven threading with state machine pattern
- **GUI Framework:** Tkinter
- **Testing:** pytest with pytest-mock for SDK mocking
- **Platform:** Windows-only (pywinauto for window automation), but supports cross-platform development via mock implementations
- **Key Dependencies:** pyirsdk (iRacing SDK), pywinauto (Windows automation), codetiming (performance monitoring)

## Architecture Overview

Python 3.13 desktop app: Tkinter GUI + iRacing SDK integration. Two threads: main thread runs the GUI (`App`), a worker thread runs the `Generator` detection loop at ~1 Hz.

**Data flow:** `Generator._loop()` → `Drivers.update()` (fetches SDK telemetry with double-buffering for delta detection) → `Detector.detect()` (runs enabled sub-detectors) → `ThresholdChecker.register_detection_result()` → `ThresholdChecker.threshold_met()` → if met, `Generator._start_safety_car()` sends chat commands to iRacing.

**Detection system** uses composite/protocol pattern: `Detector` holds a list of `SupportsDetect` implementations (RandomDetector, StoppedDetector, OffTrackDetector). Each returns `DetectionResult` which feeds into `ThresholdChecker`'s sliding time window with per-driver event tracking, proximity clustering, and dynamic race-start multipliers.

**Safety car procedures** after deployment: pace laps → wave arounds (3 strategies via factory) → optional class split via `!eol` commands.

**Cross-thread coordination:** `threading.Event` objects (`shutdown_event`, `throw_manual_sc_event`, `skip_wait_for_green_event`). No shared mutable state. App polls `generator.state` for GUI updates.

**Settings** persist via `ConfigParser` in `src/settings.ini`, wrapped by typed property accessors in `src/core/settings.py`.

## Critical Patterns to Follow

### 1. State Machine Pattern (GeneratorState)

The Generator uses a strict state machine with property-based transitions:

```python
class GeneratorState(Enum):
    STOPPED = 1
    CONNECTING_TO_IRACING = 2
    CONNECTED = 3
    WAITING_FOR_RACE_SESSION = 5
    WAITING_FOR_GREEN = 6
    MONITORING_FOR_INCIDENTS = 7
    SAFETY_CAR_DEPLOYED = 8
    UNCAUGHT_EXCEPTION = 9
```

**State Transitions:**

- `STOPPED` → `CONNECTING_TO_IRACING` (user clicks start)
- `CONNECTING_TO_IRACING` → `CONNECTED` (SDK connection established)
- `CONNECTED` → `WAITING_FOR_RACE_SESSION` (connection verified)
- `WAITING_FOR_RACE_SESSION` → `WAITING_FOR_GREEN` (race session started)
- `WAITING_FOR_GREEN` → `MONITORING_FOR_INCIDENTS` (green flag shown)
- `MONITORING_FOR_INCIDENTS` ↔ `SAFETY_CAR_DEPLOYED` (threshold met / green flag)

**Property-Based Access (src/core/app.py:161-165):**

```python
@property
def generator_state(self) -> GeneratorState:
    return self._generator_state

@generator_state.setter
def generator_state(self, value: GeneratorState):
    self._generator_state = value
    self.on_generator_state_change()  # Updates GUI automatically
```

**When to modify:** Only add new states if adding fundamentally new operational modes. Always use the property setter for transitions to ensure GUI updates.

### 2. Double-Buffering Pattern (Drivers)

The Drivers class maintains two copies of driver data to enable delta detection:

```python
# src/core/drivers.py:11-18
class Drivers:
    def __init__(self):
        self.current_drivers: list[Driver] = []
        self.previous_drivers: list[Driver] = []

    def update(self, ir):
        self.previous_drivers = self.current_drivers.copy()
        self.current_drivers = self._build_drivers(ir)
```

**Purpose:** Detect stopped cars by comparing `total_distance` between current and previous frames.

**When to modify:** Add new fields to the Driver TypedDict if you need additional driver properties for detection.

### 3. Protocol Pattern (SupportsDetect)

Detectors use structural typing via Protocol for loose coupling:

```python
# src/core/detection/detector_common_types.py:41-49
class SupportsDetect(Protocol):
    def detect(self) -> DetectionResult:
        """Run detection and return results."""
        ...

    def should_run(self, state: DetectorState) -> bool:
        """Check if detector should run based on current state."""
        ...
```

**When to add new detector:**

1. Implement the `SupportsDetect` protocol
2. Add event type to `DetectorEventTypes` enum
3. Update `Detector.build_detector()` to instantiate your detector
4. Add settings to `DetectorSettings` dataclass

### 4. Builder Pattern (Detector)

The composite Detector is constructed via a builder:

```python
# src/core/detection/detector.py — build_detector()
@staticmethod
def build_detector(settings: DetectorSettings, drivers: Drivers):
    """Build detector with enabled sub-detectors based on settings.

    Each detector is instantiated if individually enabled OR if its
    accumulative weight is non-zero (so it contributes to weighted thresholds).
    """
    detectors = {}

    if settings.stopped_detector_enabled or settings.accumulative_weights.get(DetectorEventTypes.STOPPED, 0) > 0:
        detectors[DetectorEventTypes.STOPPED] = StoppedDetector(drivers)

    if settings.off_track_detector_enabled or settings.accumulative_weights.get(DetectorEventTypes.OFF_TRACK, 0) > 0:
        detectors[DetectorEventTypes.OFF_TRACK] = OffTrackDetector(drivers)

    # ... same pattern for other detectors
    return Detector(detectors)
```

**When to modify:** Add new detector types to the builder when creating new detection algorithms. Remember to check both the `_enabled` flag and `accumulative_weights` for the new event type.

### 5. Factory Pattern

Multiple factory functions create appropriate implementations based on context:

```python
# src/core/interactions/interaction_factories.py:7-14
def CommandSenderFactory(arguments: argparse.Namespace, ir: irsdk.IRSDK) -> SupportsCommandSending:
    if arguments.dont_use_windows_interactions:
        return MockSender()
    else:
        iracing_window = IracingWindow()
        return CommandSender(ir, iracing_window)
```

```python
# src/core/procedures/wave_arounds.py:182-191
def wave_arounds_factory(wave_around_type: WaveAroundType):
    if wave_around_type == WaveAroundType.WAVE_LAPPED_CARS:
        return get_lapped_cars_wave_around_commands
    elif wave_around_type == WaveAroundType.WAVE_AHEAD_OF_CLASS_LEAD:
        return get_ahead_of_class_lead_wave_around_commands
    elif wave_around_type == WaveAroundType.WAVE_COMBINED:
        return get_combined_wave_around_commands
```

**Naming convention:** Factory functions end with `_factory` or use `Factory` suffix.

### 6. Event-Based Threading

Generator runs in a separate thread coordinated via `threading.Event` objects:

```python
# src/core/generator.py:37-40
self.shutdown_event = threading.Event()
self.throw_manual_sc_event = threading.Event()
self.skip_wait_for_green_event = threading.Event()
```

**Thread Safety:**

- Main thread: Tkinter GUI (App)
- Generator thread: Detection loop and procedures
- No shared mutable state between threads
- Generator reads from iRacing SDK (thread-safe)
- App polls `generator.state` property for updates

## Code Conventions

### Naming

- **Variables/functions:** `snake_case`
- **Classes:** `PascalCase`
- **Constants/Enums:** `UPPER_CASE`
- **Private methods:** `_leading_underscore`
- **Factory functions:** `function_name_factory` or `FunctionFactory`

### Type Hints

**Always use type hints for:**

- Function parameters and return values
- Class attributes (especially in TypedDict)
- Variables when type isn't obvious from assignment

**TypedDict for data models:**

```python
# src/core/drivers.py:5-14
class Driver(TypedDict):
    driver_idx: int
    car_number: str
    car_class_id: int
    is_pace_car: bool
    laps_completed: int
    laps_started: int
    lap_distance: float
    total_distance: float
    track_loc: TrkLoc
    on_pit_road: bool
```

**Dataclasses for configuration:**

```python
# src/core/detection/detector_common_types.py:53-60
@dataclass(frozen=True)
class DetectorSettings:
    random_detector_enabled: bool = False
    random_detector_settings: RandomDetectorSettings = field(default_factory=RandomDetectorSettings)
    stopped_detector_enabled: bool = False
    stopped_detector_settings: StoppedDetectorSettings = field(default_factory=StoppedDetectorSettings)
    off_track_detector_enabled: bool = False
    off_track_detector_settings: OffTrackDetectorSettings = field(default_factory=OffTrackDetectorSettings)
```

### Logging

**Per-module loggers:**

```python
import logging
logger = logging.getLogger(__name__)
```

**Log levels:**

- `logger.debug()`: Detailed diagnostic information
- `logger.info()`: General informational messages (state changes, events)
- `logger.warning()`: Unexpected behavior that doesn't stop execution
- `logger.error()`: Errors that affect functionality
- `logger.exception()`: Exceptions with stack traces

**Configuration:** Logging is configured via `src/logging.json` and outputs to `logs/{timestamp}.log`

### Docstrings

Use Google-style docstrings:

```python
def function_name(param1: type1, param2: type2) -> return_type:
    """Brief one-line description.

    Longer description if needed, explaining purpose and behavior.

    Args:
        param1: Description of param1
        param2: Description of param2

    Returns:
        Description of return value
    """
```

## Testing Patterns

### Test Organization

Tests are located in `tests/` subdirectories within each module:

```
src/core/
├── app.py
├── generator.py
├── tests/
│   ├── test_app.py
│   ├── test_generator.py
│   └── test_utils.py
└── detection/
    ├── detector.py
    ├── threshold_checker.py
    └── tests/
        ├── test_detector.py
        └── test_threshold_checker.py
```

### Common Fixtures and Utilities

**Use test utilities from `src/core/tests/test_utils.py`:**

```python
from core.tests.test_utils import make_driver, dict_to_config

# Create test drivers with specific properties
driver = make_driver(
    driver_idx=1,
    car_number="42",
    laps_completed=10,
    lap_distance=0.5,
    track_loc=TrkLoc.on_track
)

# Convert dict to configparser for testing
config = dict_to_config({"General": {"setting_name": "value"}})
```

### Mocking the iRacing SDK

Use `pytest-mock` to mock SDK calls:

```python
def test_something(mocker):
    # Mock time for deterministic tests
    mocker.patch("time.time", return_value=1000.0)

    # Mock SDK methods
    mock_ir = mocker.Mock()
    mock_ir["CarIdxLap"] = [0, 1, 2, 3]  # Array indexed by CarIdx
    mock_ir["CarIdxLapDistPct"] = [0.0, 0.5, 0.75, 0.25]
```

### Test Naming

- Test files: `test_module_name.py`
- Test functions: `test_function_behavior_condition`
- Example: `test_threshold_met_with_proximity_clustering`

## Common Gotchas

### iRacing SDK Quirks

**1. Negative lap progress:**
The SDK occasionally returns negative values for `CarIdxLapDistPct`. Always filter these out:

```python
# src/core/detection/stopped_detector.py:47-48
if driver["lap_distance"] < 0:
    continue  # Skip this driver
```

**2. Entire field appears stopped (lag detection):**
If the SDK lags, all cars may show as stopped. Detect and ignore this:

```python
# src/core/detection/stopped_detector.py:58-64
# Check for lag - if too many cars are stopped, it's probably lag
if len(stopped_drivers) > self.settings.lag_protection_car_threshold:
    logger.warning(f"Detected {len(stopped_drivers)} stopped cars - clearing list (possible lag)")
    return DetectionResult(DetectorEventTypes.STOPPED, drivers=[])
```

**3. Pace car in driver list:**
The pace car is included in all driver arrays. Always filter it out:

```python
if driver["is_pace_car"]:
    continue
```

**4. Cars in pits:**
Check both `on_pit_road` and `track_loc` for comprehensive pit detection:

```python
# src/core/detection/stopped_detector.py:51-53
if driver["track_loc"] in [TrkLoc.aproaching_pits, TrkLoc.in_pit_stall] or driver["track_loc"] == TrkLoc.not_in_world:
    continue
```

**5. TrkLoc is not a standard Python Enum:**
`irsdk.TrkLoc` looks like an enum but is a custom class — it is **not iterable** (`for t in TrkLoc` raises `TypeError`). Its values are plain integers:

| Constant                 | Value |
| ------------------------ | ----- |
| `TrkLoc.not_in_world`    | `-1`  |
| `TrkLoc.off_track`       | `0`   |
| `TrkLoc.in_pit_stall`    | `1`   |
| `TrkLoc.aproaching_pits` | `2`   |
| `TrkLoc.on_track`        | `3`   |

Note the **typo** `aproaching_pits` (one 'p') — this is the actual irsdk constant name. In NDJSON dumps, `CarIdxTrackSurface` stores these as raw integers, so comparisons work with either the constant or the int value. When writing tests against dump data, compare with the `TrkLoc` constants.

### Threading Model

**Generator runs in separate thread:**

- Main loop runs at ~1 Hz (1 second sleep + loop execution time)
- Uses `threading.Event` for coordination (shutdown, manual SC, skip wait)
- Never directly modify GUI from Generator thread
- App polls `generator.state` property for updates

### Windows Automation Timing

**Command delays are critical:**

```python
# src/core/interactions/command_sender.py:33-34
time.sleep(0.1)  # Wait for iRacing UI to update
# ... send command ...
time.sleep(0.5)  # Delay between commands to avoid rate limiting
```

**Focus requirement:**

- pywinauto requires the iRacing window to have focus
- Users cannot alt-tab during safety car procedures
- Use `-dwi` flag for development without Windows automation

### State Management

**Always use property setters:**

```python
# Good - triggers GUI update
self.generator_state = GeneratorState.MONITORING_FOR_INCIDENTS

# Bad - bypasses GUI update
self._generator_state = GeneratorState.MONITORING_FOR_INCIDENTS
```

## Domain-Specific Logic

### Wave Around Strategies

Three strategies (see `src/core/procedures/wave_arounds.py`):

1. **WAVE_LAPPED_CARS**: Cars 2+ laps down OR 1 lap down and behind class leader
2. **WAVE_AHEAD_OF_CLASS_LEAD**: Cars ahead of class leader in running order but behind overall leader
3. **WAVE_COMBINED**: Union of both strategies

**Execution order:** Commands sent in running order behind safety car (closest to SC first)

### Threshold Checker Sliding Window

The ThresholdChecker uses a deque for FIFO event tracking with time-based cleanup:

```python
# src/core/detection/threshold_checker.py:32-39
self.event_queue: deque[tuple[float, DetectorEventTypes, Driver]] = deque()
self.driver_event_counts: dict[DetectorEventTypes, dict[int, int]] = {
    event_type: {} for event_type in DetectorEventTypes
}

def clean_up_events(self, current_time: float):
    """Remove events older than time_range seconds."""
    while self.event_queue and (current_time - self.event_queue[0][0]) > self.settings.time_range:
        # Remove old event and decrement count
```

**Key features:**

- Events expire after `time_range` seconds (default: 5s)
- Per-driver tracking prevents double-counting
- Supports both per-event-type and accumulative (weighted) thresholds
- `individually_enabled_event_types` gates per-event-type threshold checks — detectors running only for accumulative weight contribution skip individual threshold evaluation
- Dynamic threshold multipliers during race start period

### Proximity Clustering

Groups nearby incidents to distinguish between spread-out minor incidents and clustered major incidents:

```python
# src/core/detection/threshold_checker.py:134-156
def _create_proximity_clusters(self, latest_events, proximity_distance: float):
    """Group events within proximity_distance of each other."""
    # Sort by lap position
    # Create clusters using sliding window
    # Handle wrap-around at finish line (extend positions by +1 lap)
```

**When enabled:** Only the largest cluster is checked against thresholds, ignoring spread-out incidents.

### Detection System Composite

The Detector coordinates multiple detection algorithms:

```python
# src/core/detection/detector.py:52-61
def detect(self) -> BundledDetectedEvents:
    """Run all enabled detectors and bundle results."""
    results: list[DetectionResult] = []

    for detector in self.detectors:
        if detector.should_run(self.detector_state):
            result = detector.detect()
            if result:
                results.append(result)

    return BundledDetectedEvents(results)
```

**Key insight:** Each detector independently decides if it should run based on `DetectorState` (time window, lap range, etc.)

## Extension Points

### Adding a New Detector

1. Create `src/core/detection/your_detector.py` implementing `SupportsDetect` protocol
2. Add event type to `DetectorEventTypes` enum in `detector_common_types.py`
3. Add settings dataclass for your detector
4. Update `DetectorSettings` dataclass with your detector's enabled flag and settings
5. Update `Detector.build_detector()` to instantiate your detector — check both the `_enabled` flag and `accumulative_weights` for the new event type
6. Add threshold settings to `ThresholdCheckerSettings`
7. Create tests in `src/core/detection/tests/test_your_detector.py`

### Adding a New Wave Around Strategy

1. Add enum value to `WaveAroundType` in `wave_arounds.py`
2. Implement function matching signature: `(drivers: Drivers, pace_car_idx: int) -> list[str]`
3. Update `wave_arounds_factory()` to return your function
4. Add tests

## Testing Requirements

- **New features**: Always include unit tests and integration tests where applicable. Plan for testing as part of the implementation, not as an afterthought.
- **Bug fixes**: Always write a regression test that **fails before** the fix and **passes after** the fix. This proves the bug is reproduced and resolved.
- **E2E tests**: For detection pipeline changes, add scenarios to the e2e test framework in `src/core/tests/test_e2e_detection_and_procedures.py` using real SDK dumps from `docs/dumps/`.

## Post-Implementation Checklist

After completing an implementation, review the PR checklist (`.github/pull_request_template.md`):

**Code quality:**
- Code follows project style guidelines
- Self-review performed
- Hard-to-understand areas are commented
- No new warnings generated
- Tests added/updated and all pass locally

**Documentation updates — ALWAYS review and update these files when relevant:**
- `ARCHITECTURE.md` — if changing system design, components, data flow, or workflows
- `.ai-modules.md` — if adding/removing modules, changing module responsibilities or dependencies
- `.ai-context.md` — if adding new patterns, conventions, or gotchas
- `CLAUDE.md` — if changing commands, context files, or workflow instructions
- `CONTRIBUTING.md` — if changing development setup, commit conventions, or PR process
- `README.md` — if changing user-facing features, setup instructions, or configuration
- `docs/RACING_CONCEPTS.md` — if adding new racing concepts or domain terminology

These updates are **not optional** — skipping them causes knowledge drift that compounds over time. When in doubt, check the file and update it.

## Quick Command Reference

```bash
# Run application
cd src && python main.py              # Normal mode
cd src && python main.py -dev         # Developer mode (extra GUI panel)
cd src && python main.py -dev -dwi    # Cross-platform dev (no Windows automation)
cd src && python main.py -dry         # Dry run mode (shows warning)

# Tests
pytest                                # Run all tests
pytest -v                             # Verbose
pytest -k test_name                   # Run specific test by name
pytest src/core/detection/tests/      # Run tests in a directory
pytest --cov                          # With coverage

# Build
python build.py                       # Create Windows executable via PyInstaller
```

## Resources

- **iRacing SDK Documentation:** https://sajax.github.io/irsdkdocs/yaml
- **pyirsdk Library:** https://github.com/kutu/pyirsdk
- **Contributing Guidelines:** See `CONTRIBUTING.md` for development environment setup, commit conventions, and PR process
- **Project Architecture:** See `ARCHITECTURE.md` for detailed system design
