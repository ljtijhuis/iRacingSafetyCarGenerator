# Module Reference Guide

Quick reference for module responsibilities, dependencies, and when to modify each component.

## Application Entry Point

### `src/main.py` (52 lines)
**Role:** Application entry point and initialization

**Key Functions:**
- `setup_logging()` - Configures logging from `logging.json`
- `parse_arguments()` - Handles command-line flags (-dev, -dwi, -dry)

**Dependencies:** App, logging configuration

**When to Modify:**
- Adding new command-line arguments
- Changing logging setup
- Modifying application initialization

---

## Core Application Modules

### `src/core/app.py` (1433 lines)
**Role:** Main Tkinter GUI application with state management

**Key Classes:**
- `App(tk.Tk)` - Main application window
- Manages 3-column layout: detectors, settings, controls
- Property-based state machine (`generator_state` property)

**Dependencies:**
- `Generator` - Core engine controlled by GUI
- `Settings` - Configuration management
- `Tooltip` - UI tooltip system

**Key State Management:**
```python
@property
def generator_state(self) -> GeneratorState:
    return self._generator_state

@generator_state.setter
def generator_state(self, value: GeneratorState):
    self._generator_state = value
    self.on_generator_state_change()  # Triggers GUI updates
```

**When to Modify:**
- GUI layout changes
- Adding/modifying settings widgets
- State display updates
- Button behaviors

**Important Notes:**
- Runs in main thread (Tkinter mainloop)
- Polls `generator.state` for updates
- Never directly modifies Generator state

---

### `src/core/generator.py` (509 lines)
**Role:** Core engine orchestrating detection and safety car procedures

**Key Classes:**
- `Generator` - Main orchestrator (runs in separate thread)
- `GeneratorState(Enum)` - State machine enum

**Thread Model:**
- Runs in separate thread via `self.thread = threading.Thread(target=self.run)`
- Coordination via `threading.Event`: `shutdown_event`, `throw_manual_sc_event`, `skip_wait_for_green_event`

**Key Workflows:**
- `run()` - Main entry point (connects to iRacing, waits for green, starts loop)
- `_loop()` - Detection loop (~1 Hz)
- `_start_safety_car()` - Safety car procedure execution

**Dependencies:**
- `Detector` - Composite detector for all detection types
- `ThresholdChecker` - Event aggregation and threshold checking
- `CommandSender` - iRacing command execution
- `Drivers` - Driver state management
- `wave_arounds` - Wave around strategies

**When to Modify:**
- Main loop logic changes
- Safety car procedure modifications
- State transition logic
- Timing and eligibility windows

**Important Notes:**
- Thread-safe: no shared mutable state with main thread
- Updates own state via property setter
- Loop runs at ~1 Hz (1 second sleep + processing)

---

## Detection System

### `src/core/detection/detector.py` (84 lines)
**Role:** Composite detector coordinating all detection types

**Key Classes:**
- `Detector` - Composite pattern coordinator
- Builder pattern via `build_detector()` static method

**Key Methods:**
```python
@staticmethod
def build_detector(settings: DetectorSettings, drivers: Drivers) -> "Detector":
    """Build detector with enabled sub-detectors."""
    ...

def detect(self) -> BundledDetectedEvents:
    """Run all enabled detectors and bundle results."""
    ...

def race_started(self, start_time: float):
    """Notify all detectors that race has started."""
    ...
```

**Dependencies:**
- `RandomDetector`, `StoppedDetector`, `OffTrackDetector` - Individual detectors
- `Drivers` - Driver state for detection
- `DetectorSettings` - Configuration for which detectors are enabled

**When to Modify:**
- Adding new detector types
- Changing detection coordination logic
- Modifying race start notifications

**Extension Point:**
- Add new detector type in `build_detector()`
- Ensure detector implements `SupportsDetect` protocol

---

### `src/core/detection/detector_common_types.py` (118 lines)
**Role:** Shared types, protocols, and enums for detection system

**Key Types:**
- `DetectorEventTypes(Enum)` - Event type identifiers (RANDOM, STOPPED, OFF_TRACK)
- `SupportsDetect(Protocol)` - Interface for all detectors
- `DetectorState` - Current state passed to detectors (time, lap, counts)
- `DetectionResult` - Result from a detector
- `BundledDetectedEvents` - Collection of results from all detectors
- `DetectorSettings` - Configuration for all detectors (dataclass)
- `ThresholdCheckerSettings` - Threshold configuration (dataclass)

**When to Modify:**
- Adding new event types (extend `DetectorEventTypes` enum)
- Adding new detector settings (extend `DetectorSettings`)
- Adding new threshold settings (extend `ThresholdCheckerSettings`)

**Important Notes:**
- Protocol pattern enables loose coupling
- Dataclasses are frozen (immutable)
- Settings built via `from_settings()` factory method

---

### `src/core/detection/threshold_checker.py` (374 lines)
**Role:** Event aggregation with sliding time window and threshold checking

**Key Algorithm:**
- Maintains event queue: `deque[(timestamp, event_type, driver)]`
- Per-driver counts: `dict[event_type, dict[driver_idx, count]]`
- Cleans up events older than `time_range` seconds
- Supports proximity clustering (group nearby incidents)
- Dynamic threshold scaling during race start

**Key Methods:**
```python
def register_detection_result(result: DetectionResult, current_time: float):
    """Add new events to queue for each detected driver."""
    ...

def clean_up_events(current_time: float):
    """Remove events older than time_range."""
    ...

def threshold_met(current_time: float, race_start_time: float) -> tuple[bool, str]:
    """Check if thresholds exceeded (per-type or accumulative)."""
    ...
```

**Dependencies:**
- `ThresholdCheckerSettings` - Configuration
- `Driver` - Driver information for events

**When to Modify:**
- Threshold calculation logic
- Proximity clustering algorithm
- Dynamic threshold scaling
- Event expiration logic

**Important Notes:**
- Uses deque for FIFO event tracking
- Prevents double-counting with per-driver tracking
- Proximity clustering handles finish-line wrap-around

---

### `src/core/detection/random_detector.py` (69 lines)
**Role:** Probabilistic safety car deployment

**Key Logic:**
- Converts overall race probability to per-second probability
- Time window constraints (start_minute to end_minute)
- Returns `DetectionResult` with `detected_flag` (not drivers)

**Key Methods:**
```python
def detect(self) -> DetectionResult:
    """Check if random event should trigger."""
    ...

def should_run(self, state: DetectorState) -> bool:
    """Check if within time window."""
    ...
```

**Dependencies:**
- `RandomDetectorSettings` - Configuration

**When to Modify:**
- Probability calculation logic
- Time window behavior

---

### `src/core/detection/stopped_detector.py` (82 lines)
**Role:** Detects stopped cars by comparing positions between frames

**Key Logic:**
- Compares `total_distance` (laps_completed + lap_distance) between current/previous
- Filters out: pace car, cars in pits, negative lap_distance
- Lag protection: if too many cars stopped, likely SDK lag

**Key Methods:**
```python
def detect(self) -> DetectionResult:
    """Find cars that haven't moved since last frame."""
    ...
```

**Dependencies:**
- `Drivers` - Current and previous driver states
- `StoppedDetectorSettings` - Configuration including lag threshold

**When to Modify:**
- Stopped car detection logic
- Pit/pace car filtering
- Lag detection threshold

**Important Notes:**
- Requires double-buffered driver data
- Filters cars in pits via `track_loc` and `on_pit_road`
- Lag protection prevents false positives

---

### `src/core/detection/off_track_detector.py` (47 lines)
**Role:** Detects cars off track surface

**Key Logic:**
- Checks `track_loc == TrkLoc.off_track`
- Filters cars with negative laps_completed

**Key Methods:**
```python
def detect(self) -> DetectionResult:
    """Find cars currently off track."""
    ...
```

**Dependencies:**
- `Drivers` - Current driver states
- `OffTrackDetectorSettings` - Configuration

**When to Modify:**
- Off-track detection criteria
- Additional filtering logic

---

## Data Management

### `src/core/drivers.py` (91 lines)
**Role:** Driver state management with double-buffering

**Key Classes:**
- `Driver(TypedDict)` - Driver data structure
- `Drivers` - Manager with current/previous buffers

**Key Fields in Driver:**
```python
driver_idx: int          # SDK array index
car_number: str          # Visible car number
car_class_id: int        # Class for multi-class racing
is_pace_car: bool        # Pace car flag
laps_completed: int      # Full laps crossed
lap_distance: float      # Fraction of current lap (0.0-1.0)
total_distance: float    # laps_completed + lap_distance
track_loc: TrkLoc        # On track, off track, in pits, etc.
on_pit_road: bool        # On pit entry/exit
```

**Key Methods:**
```python
def update(self, ir):
    """Update driver data from iRacing SDK."""
    self.previous_drivers = self.current_drivers.copy()
    self.current_drivers = self._build_drivers(ir)
```

**Dependencies:**
- `irsdk.IRSDK` - iRacing SDK for data

**When to Modify:**
- Adding new driver properties
- Changing data extraction from SDK
- Modifying filtering logic

**Important Notes:**
- Double-buffering enables stopped car detection
- `total_distance` is key metric for position/movement
- Filters out pace car and invalid entries

---

### `src/core/settings.py` (250 lines)
**Role:** Type-safe wrapper around ConfigParser

**Pattern:** Properties with getters/setters for each setting

**Example:**
```python
@property
def max_sc_events(self) -> int:
    return self.config.getint("General", "max_sc_events", fallback=5)

@max_sc_events.setter
def max_sc_events(self, value: int):
    self.config.set("General", "max_sc_events", str(value))
```

**File Location:** `src/settings.ini`

**Dependencies:**
- `configparser.ConfigParser`

**When to Modify:**
- Adding new settings
- Changing default values
- Modifying setting categories

**Important Notes:**
- Always provide fallback defaults
- Use appropriate type conversion (getint, getfloat, getboolean)
- Boolean values stored as 0/1 in INI file

---

## Procedures

### `src/core/procedures/wave_arounds.py` (191 lines)
**Role:** Wave around strategy implementations

**Key Components:**
- `WaveAroundType(Enum)` - Strategy types
- Three strategy implementations:
  1. `get_lapped_cars_wave_around_commands()` - Cars 2+ laps down or 1 lap behind class leader
  2. `get_ahead_of_class_lead_wave_around_commands()` - Cars ahead of class leader but behind overall leader
  3. `get_combined_wave_around_commands()` - Union of both strategies

**Factory Pattern:**
```python
def wave_arounds_factory(wave_around_type: WaveAroundType):
    """Return appropriate wave around function."""
    ...
```

**Key Utilities:**
- `positions_from_safety_car()` - Calculate positions relative to pace car

**Dependencies:**
- `Drivers` - Driver positions and data

**When to Modify:**
- Adding new wave around strategies
- Modifying existing strategy logic
- Changing position calculation

**Extension Point:**
- Add new `WaveAroundType` enum value
- Implement function with signature: `(Drivers, int) -> list[str]`
- Update `wave_arounds_factory()`

---

## Interactions (Windows Automation)

### `src/core/interactions/command_sender.py` (60 lines)
**Role:** Send chat commands to iRacing via window automation

**Key Methods:**
```python
def send_command(self, command: str):
    """Send single command to iRacing chat."""
    # 1. Open chat via SDK: ir.chat_command(1)
    # 2. Focus window via pywinauto
    # 3. Paste command via clipboard + Ctrl+V
    # 4. Send via Enter key
    # 5. Wait 0.5s (rate limiting)
    ...

def send_commands(self, commands: list[str], delay: float = 0.5):
    """Send multiple commands with delays."""
    ...
```

**Dependencies:**
- `irsdk.IRSDK` - For opening chat interface
- `IracingWindow` - pywinauto window wrapper
- `pyperclip` - Clipboard operations
- `pywinauto.keyboard` - Key sending

**When to Modify:**
- Command sending logic
- Timing/delays
- Error handling

**Important Notes:**
- Windows-only (requires pywinauto)
- Requires window focus
- 0.5s delay between commands to avoid rate limiting

---

### `src/core/interactions/interaction_factories.py` (22 lines)
**Role:** Factory for creating command senders

**Key Function:**
```python
def CommandSenderFactory(arguments: argparse.Namespace, ir: irsdk.IRSDK) -> SupportsCommandSending:
    """Create real or mock command sender based on flags."""
    if arguments.dont_use_windows_interactions:
        return MockSender()  # Cross-platform dev
    else:
        return CommandSender(ir, IracingWindow())  # Production
```

**When to Modify:**
- Adding new interaction types
- Changing factory logic

---

### `src/core/interactions/mock_sender.py` (10 lines)
**Role:** Mock command sender for cross-platform development

**Key Behavior:**
- Logs commands instead of sending
- No Windows automation
- Enables development on macOS/Linux

**When to Modify:**
- Adding mock logging details
- Simulating command delays

---

### `src/core/interactions/iracing_window.py` (23 lines)
**Role:** Wrapper around pywinauto for iRacing window

**Key Methods:**
```python
def set_focus(self):
    """Bring iRacing window to focus."""
    self.app.connect(title_re=".*iRacing.*")
    # ... focus logic
```

**Dependencies:**
- `pywinauto.Application`

**When to Modify:**
- Window detection logic
- Focus behavior

**Important Notes:**
- Windows-only
- Requires iRacing to be running

---

## Utility Modules

### `src/util/generator_utils.py` (48 lines)
**Role:** Utility functions for generator operations

**Key Functions:**
- `get_pace_car(ir)` - Find pace car index from SDK
- `get_current_lap(ir)` - Get current lap number from SDK

**When to Modify:**
- Adding new SDK helper functions
- Modifying data extraction logic

---

### `src/util/state_utils.py` (27 lines)
**Role:** State management utilities

**Key Functions:**
- Session state checking helpers

**When to Modify:**
- Adding state-related utilities

---

### `src/util/dev_utils.py` (28 lines)
**Role:** Development/debugging utilities

**Key Functions:**
- `dump_sdk_data()` - Export SDK data to JSON file

**When to Modify:**
- Adding new development tools
- Adding debugging helpers

---

## Testing Utilities

### `src/core/tests/test_utils.py` (94 lines)
**Role:** Common test fixtures and utilities

**Key Functions:**
```python
def make_driver(...) -> Driver:
    """Create test Driver with specified properties."""
    ...

def dict_to_config(config_dict: dict) -> configparser.ConfigParser:
    """Convert dict to ConfigParser for testing."""
    ...
```

**When to Modify:**
- Adding new test fixtures
- Adding test data builders

**Important Notes:**
- Used extensively across all test files
- Provides consistent test data creation

---

## UI Support

### `src/core/tooltip.py` (48 lines)
**Role:** Tooltip functionality for GUI

**Key Classes:**
- `Tooltip` - Hover tooltip implementation

**Dependencies:**
- `tooltips_text.json` - Tooltip text content

**When to Modify:**
- Changing tooltip behavior
- Modifying tooltip styling

---

## Configuration Files

### `src/settings.ini`
**Role:** User settings persistence

**Sections:**
- `[General]` - Overall settings (max events, timing)
- `[RandomDetector]` - Random SC settings
- `[StoppedDetector]` - Stopped car settings
- `[OffTrackDetector]` - Off-track settings
- `[ThresholdChecker]` - Threshold and weighting settings
- `[WaveArounds]` - Wave around strategy and timing

---

### `src/logging.json`
**Role:** Logging configuration

**Controls:**
- Log level (DEBUG, INFO, WARNING, ERROR)
- File output location (`logs/`)
- Log format

---

### `src/tooltips_text.json`
**Role:** Tooltip text content

**When to Modify:**
- Adding new tooltips
- Updating help text

---

## Build and Deployment

### `build.py` (21 lines)
**Role:** Build script for creating executable

**Key Functionality:**
- Uses PyInstaller to create standalone executable
- Bundles dependencies and assets

**When to Modify:**
- Adding new assets to bundle
- Changing build configuration
- Modifying icon or version info

---

## Module Dependency Graph

```
main.py
    └── App (core/app.py)
        └── Generator (core/generator.py)
            ├── Detector (detection/detector.py)
            │   ├── RandomDetector
            │   ├── StoppedDetector
            │   └── OffTrackDetector
            ├── ThresholdChecker (detection/threshold_checker.py)
            ├── CommandSender (interactions/command_sender.py)
            │   ├── IracingWindow (interactions/iracing_window.py) [Windows]
            │   └── MockSender (interactions/mock_sender.py) [Dev]
            ├── Drivers (core/drivers.py)
            └── wave_arounds (procedures/wave_arounds.py)
```

---

## Quick Navigation Guide

**Need to change detection logic?** → `src/core/detection/`
**Need to change GUI?** → `src/core/app.py`
**Need to change safety car procedure?** → `src/core/generator.py` (_start_safety_car, _send_wave_arounds)
**Need to change wave around rules?** → `src/core/procedures/wave_arounds.py`
**Need to change thresholds?** → `src/core/detection/threshold_checker.py`
**Need to add settings?** → `src/core/settings.py` + `src/settings.ini`
**Need to change Windows automation?** → `src/core/interactions/`
**Need to add tests?** → `src/*/tests/` (co-located with source)

---

## See Also

- `.ai-context.md` - Patterns, conventions, and gotchas
- `ARCHITECTURE.md` - System design and workflows
- `CONTRIBUTING.md` - Development guidelines
- `docs/RACING_CONCEPTS.md` - Racing domain knowledge
